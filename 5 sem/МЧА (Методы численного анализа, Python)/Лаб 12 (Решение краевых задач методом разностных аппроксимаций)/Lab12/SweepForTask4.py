# аппроксимация производных по методу баланса
import numpy as np

# метод прогонки
def sweep_method(k1, k2, q1, q2, f, s1, s2, mu1, mu2, h, n, X, a_, b_, c_):
#def sweep_method(p, q, f_, h, n, X, al_1, be_1, al_2, be_2, A, B):
    '''метод прогонки для решения дифф. уравнения 2 порядка методом баланса с обобщенными граничными условиями 
    k1, k2, q1, q2, f, - функции от х в условии дифф уравнения
    h, n, X, - шаг, кол-во разбиений отрезка, массив точек разбиения
    s1, s2, mu1, mu2, - из обобщенных граничных условий, 
    a_, b_, c_ - границы отрезка и середина'''

    # коэффициенты трехдиагональной матрицы
    a = np.zeros(n-1)
    b = np.zeros(n-1)
    c = np.zeros(n-1)
    d = np.zeros(n-1)

    # коэффициенты трехдиагональной матрицы
    # ai[i] = k(X[i] - 0.5*h)
    # bi[i] = k(X[i] + 0.5*h)
    # di[i] = q(X[i])
    # fi[i] = f(X[i])
    i = 0
    while X[i] < c_:
        a[i] = k1(X[i] - 0.5*h)
        b[i] = -(k1(X[i] + 0.5*h) + k1(X[i] - 0.5*h) + q1(X[i]) * h**2)
        c[i] = k1(X[i] + 0.5*h)
        d[i] = -f(X[i]) * h**2
        i += 1
    while i < n-1:
        a[i] = k2(X[i] - 0.5*h)
        b[i] = -(k2(X[i] + 0.5*h) + k2(X[i] - 0.5*h) + q2(X[i]) * h**2)
        c[i] = k2(X[i] + 0.5*h)
        d[i] = -f(X[i]) * h**2
        i += 1

    # подстановка у0 и уn из обобщенных граничных условий
    b[0] += 2 * a[1]**2 / (2*a[1] + 2*h*s1 + q1(X[0])*h**2) 
    d[0] += -a[1] * (2*h*mu1 + f(X[0])*h**2) / (2*a[1] + 2*h*s1 + q1(X[0])*h**2) 
    a[-1] += 2*a[-1]*k2(X[-2] + 0.5*h) / (2*a[-1] + 2*h*s2 + q2(X[-1])*h**2) 
    d[-1] += -k2(X[-2] + 0.5*h) * (2*h*mu2 + f(X[-1])*h**2) / (2*a[-1] + 2*h*s2 + q2(X[-1])*h**2) 

    # сам метод прогонки
    n = n-1
    alpha = np.zeros(n)
    beta = np.zeros(n)

    y = np.zeros(n)
    y[0] = b[0]
    alpha[0] = -c[0] / y[0]
    beta[0] = d[0] / y[0]
    for i in range(1, n-1):
        y[i] = b[i] + a[i]*alpha[i-1]
        alpha[i] = -c[i] / y[i]
        beta[i] = (d[i] - a[i]*beta[i-1]) / y[i]
    y[n-1] = b[n-1] + a[n-1]*alpha[n-2]
    beta[n-1] = (d[n-1] - a[n-1]*beta[n-2]) / y[n-1]
    # обратный ход метода прогонки
    x = np.zeros(n)
    x[n-1] = beta[n-1]
    for i in range(n-2, -1, -1):
        x[i] = alpha[i]*x[i+1] + beta[i]

    # нахождение y0 и yn из обобщенных граничных условий
    x = np.insert(x, 0, ((2*h*mu1 + f(X[0])*h**2 + 2*a[1]*x[0]) / (2*a[1] + 2*h*s1 + q1(X[0])*h**2)))
    x = list(x)
    x.append((2*h*mu2 + f(X[-1])*h**2 + 2*a[-1]*x[-1]) / (2*a[-1] + 2*h*s2 + q2(X[-1])*h**2))
    return x

